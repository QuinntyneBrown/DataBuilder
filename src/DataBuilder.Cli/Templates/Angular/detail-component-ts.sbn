import { Component, OnInit, OnDestroy, inject, signal, CUSTOM_ELEMENTS_SCHEMA, AfterViewInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ActivatedRoute, Router, RouterModule } from '@angular/router';
import { AbstractControl, FormBuilder, FormGroup, FormsModule, ReactiveFormsModule, ValidationErrors, Validators } from '@angular/forms';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatCardModule } from '@angular/material/card';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatCheckboxModule } from '@angular/material/checkbox';
import { MatDividerModule } from '@angular/material/divider';
import { MatDatepickerModule } from '@angular/material/datepicker';
import { MatTimepickerModule } from '@angular/material/timepicker';
import { provideNativeDateAdapter } from '@angular/material/core';
import { MonacoEditorModule } from 'ngx-monaco-editor-v2';
import { {{ entity.name }} } from '../../../models/{{ entity.name_kebab_case }}.model';
import { {{ entity.name }}Service } from '../../../services/{{ entity.name_kebab_case }}.service';

@Component({
  selector: 'app-{{ entity.name_kebab_case }}-detail',
  standalone: true,
  schemas: [CUSTOM_ELEMENTS_SCHEMA],
  imports: [
    CommonModule,
    RouterModule,
    FormsModule,
    ReactiveFormsModule,
    MatFormFieldModule,
    MatInputModule,
    MatButtonModule,
    MatIconModule,
    MatCardModule,
    MatProgressSpinnerModule,
    MatSnackBarModule,
    MatCheckboxModule,
    MatDividerModule,
    MatDatepickerModule,
    MatTimepickerModule,
    MonacoEditorModule
  ],
  providers: [provideNativeDateAdapter()],
  templateUrl: './{{ entity.name_kebab_case }}-detail.component.html',
  styleUrl: './{{ entity.name_kebab_case }}-detail.component.scss'
})
export class {{ entity.name }}DetailComponent implements OnInit, AfterViewInit, OnDestroy {
  private readonly route = inject(ActivatedRoute);
  private readonly router = inject(Router);
  private readonly fb = inject(FormBuilder);
  private readonly {{ entity.name_camel_case }}Service = inject({{ entity.name }}Service);
  private readonly snackBar = inject(MatSnackBar);

  readonly loading = signal(false);
  readonly saving = signal(false);
  readonly isNew = signal(true);

  // Monaco Editor options
  readonly monacoOptions = {
    theme: 'vs-dark',
    language: 'json',
    minimap: { enabled: false },
    automaticLayout: true,
    formatOnPaste: true,
    formatOnType: true,
    scrollBeyondLastLine: false,
    lineNumbers: 'on' as const,
    tabSize: 2
  };

  // JSON string values for Monaco editors
{{~ for property in entity.non_id_properties ~}}
{{~ if property.is_complex_type ~}}
  {{ property.name_camel_case }}JsonString: string = '{{ if property.is_array }}[]{{ else }}{}{{ end }}';
{{~ end ~}}
{{~ end ~}}

  form: FormGroup = this.fb.group({
{{~ for property in entity.non_id_properties ~}}
{{~ if property.type_script_type == "boolean" ~}}
    {{ property.name_camel_case }}: [false],
{{~ else if property.is_complex_type ~}}
{{~ if property.is_required ~}}
    {{ property.name_camel_case }}: [{{ if property.is_array }}[]{{ else }}{}{{ end }}, Validators.required],
{{~ else ~}}
    {{ property.name_camel_case }}: [{{ if property.is_array }}[]{{ else }}{}{{ end }}],
{{~ end ~}}
{{~ else if property.is_date_time ~}}
{{~ if property.is_required ~}}
    {{ property.name_camel_case }}: [null as Date | null, Validators.required],
{{~ else ~}}
    {{ property.name_camel_case }}: [null as Date | null],
{{~ end ~}}
{{~ else if property.is_required ~}}
    {{ property.name_camel_case }}: ['', Validators.required],
{{~ else ~}}
    {{ property.name_camel_case }}: [''],
{{~ end ~}}
{{~ end ~}}
  });

  itemId: string | null = null;

  ngOnInit(): void {
    const id = this.route.snapshot.paramMap.get('id');
    if (id && id !== 'new') {
      this.itemId = id;
      this.isNew.set(false);
      this.loadItem(id);
    } else {
      // Check for cloned data from router state
      const clonedData = history.state?.cloneData;
      if (clonedData) {
        this.loadClonedData(clonedData);
      } else {
        // Pre-populate datetime fields with current date/time in create mode
        this.initializeDateTimeFields();
      }
    }
  }

  private initializeDateTimeFields(): void {
    const now = new Date();
{{~ for property in entity.non_id_properties ~}}
{{~ if property.is_date_time ~}}
    this.form.get('{{ property.name_camel_case }}')?.setValue(now);
{{~ end ~}}
{{~ end ~}}
  }

  private loadClonedData(data: any): void {
    this.form.patchValue({
{{~ for property in entity.non_id_properties ~}}
{{~ if !property.is_complex_type && !property.is_date_time ~}}
      {{ property.name_camel_case }}: data.{{ property.name_camel_case }},
{{~ end ~}}
{{~ end ~}}
    });
{{~ for property in entity.non_id_properties ~}}
{{~ if property.is_date_time ~}}
    if (data.{{ property.name_camel_case }}) {
      this.form.get('{{ property.name_camel_case }}')?.setValue(new Date(data.{{ property.name_camel_case }}));
    }
{{~ end ~}}
{{~ end ~}}
    // Store complex property values to be loaded after JSON editors are initialized
    this.pendingCloneData = data;
  }

  private pendingCloneData: any = null;

  ngAfterViewInit(): void {
    // For create mode (not loading), initialize JSON editor values after a tick
    if (!this.loading()) {
      setTimeout(() => {
        // Load cloned data for complex properties if present
        if (this.pendingCloneData) {
{{~ for property in entity.non_id_properties ~}}
{{~ if property.is_complex_type ~}}
          this.updateJsonEditor('{{ property.name_camel_case }}', this.pendingCloneData.{{ property.name_camel_case }} || {{ if property.is_array }}[]{{ else }}{}{{ end }});
{{~ end ~}}
{{~ end ~}}
          this.pendingCloneData = null;
        }
      });
    }
  }

  onJsonEditorChange(fieldName: string, value: string): void {
    try {
      const parsed = JSON.parse(value);
      this.form.get(fieldName)?.setValue(parsed);
      this.form.get(fieldName)?.setErrors(null);
    } catch {
      this.form.get(fieldName)?.setErrors({ invalidJson: true });
    }
  }

  ngOnDestroy(): void {
    // No cleanup needed for Monaco - it handles its own lifecycle
  }

  private loadItem(id: string): void {
    this.loading.set(true);
    this.{{ entity.name_camel_case }}Service.getById(id).subscribe({
      next: (item) => {
        this.form.patchValue({
{{~ for property in entity.non_id_properties ~}}
{{~ if !property.is_complex_type && !property.is_date_time ~}}
          {{ property.name_camel_case }}: item.{{ property.name_camel_case }},
{{~ end ~}}
{{~ end ~}}
        });
{{~ for property in entity.non_id_properties ~}}
{{~ if property.is_date_time ~}}
        if (item.{{ property.name_camel_case }}) {
          this.form.get('{{ property.name_camel_case }}')?.setValue(new Date(item.{{ property.name_camel_case }}));
        }
{{~ end ~}}
{{~ end ~}}
        this.loading.set(false);
        // Update JSON editor values after loading completes
        setTimeout(() => {
{{~ for property in entity.non_id_properties ~}}
{{~ if property.is_complex_type ~}}
          this.updateJsonEditor('{{ property.name_camel_case }}', item.{{ property.name_camel_case }} || {{ if property.is_array }}[]{{ else }}{}{{ end }});
{{~ end ~}}
{{~ end ~}}
        });
      },
      error: () => {
        this.snackBar.open('Failed to load {{ entity.display_name | string.downcase }}', 'Close', { duration: 5000 });
        this.router.navigate(['../'], { relativeTo: this.route });
      }
    });
  }

  private updateJsonEditor(fieldName: string, value: any): void {
    const jsonString = JSON.stringify(value, null, 2);
{{~ for property in entity.non_id_properties ~}}
{{~ if property.is_complex_type ~}}
    if (fieldName === '{{ property.name_camel_case }}') {
      this.{{ property.name_camel_case }}JsonString = jsonString;
    }
{{~ end ~}}
{{~ end ~}}
    this.form.get(fieldName)?.setValue(value);
  }

  save(): void {
    if (this.form.invalid) return;

    this.saving.set(true);
    const formValue = this.form.value;
    const request = {
      ...formValue,
    };

    const operation = this.isNew()
      ? this.{{ entity.name_camel_case }}Service.create(request)
      : this.{{ entity.name_camel_case }}Service.update(this.itemId!, request);

    operation.subscribe({
      next: () => {
        this.snackBar.open(
          `{{ entity.display_name }} ${this.isNew() ? 'created' : 'updated'} successfully`,
          'Close',
          { duration: 3000 }
        );
        this.router.navigate(['../'], { relativeTo: this.route });
      },
      error: () => {
        this.snackBar.open(
          `Failed to ${this.isNew() ? 'create' : 'update'} {{ entity.display_name | string.downcase }}`,
          'Close',
          { duration: 5000 }
        );
        this.saving.set(false);
      }
    });
  }

  delete(): void {
    if (confirm('Are you sure you want to delete this {{ entity.display_name | string.downcase }}? This action cannot be undone.')) {
      this.{{ entity.name_camel_case }}Service.delete(this.itemId!).subscribe({
        next: () => {
          this.snackBar.open('{{ entity.display_name }} deleted successfully', 'Close', { duration: 3000 });
          this.router.navigate(['../'], { relativeTo: this.route });
        },
        error: () => {
          this.snackBar.open('Failed to delete {{ entity.display_name | string.downcase }}', 'Close', { duration: 5000 });
        }
      });
    }
  }

  clone(): void {
    // Navigate to create page with current form data
    this.router.navigate(['../new'], {
      relativeTo: this.route,
      state: { cloneData: this.form.value }
    });
  }
}
