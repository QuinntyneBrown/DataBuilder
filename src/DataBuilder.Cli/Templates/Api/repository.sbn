using {{ core_namespace }}.Models;
using Couchbase;
using Couchbase.Extensions.DependencyInjection;
using Couchbase.KeyValue;
using Couchbase.Query;
using Microsoft.Extensions.Logging;
using Gateway.Core.Extensions;
using Gateway.Core.Filtering;

namespace {{ namespace }}.Data;

/// <summary>
/// Repository interface for {{ entity.display_name }} data access.
/// </summary>
public interface I{{ entity.name }}Repository
{
    Task<{{ entity.name }}?> GetByIdAsync(string id, CancellationToken cancellationToken = default);
    Task<IEnumerable<{{ entity.name }}>> GetAllAsync(CancellationToken cancellationToken = default);
    Task<PagedResult<{{ entity.name }}>> GetPageAsync(int pageIndex, int pageSize, CancellationToken cancellationToken = default);
    Task<{{ entity.name }}> CreateAsync({{ entity.name }} entity, CancellationToken cancellationToken = default);
    Task<{{ entity.name }}?> UpdateAsync({{ entity.name }} entity, CancellationToken cancellationToken = default);
    Task<bool> DeleteAsync(string id, CancellationToken cancellationToken = default);
}

/// <summary>
/// Repository implementation for {{ entity.display_name }} using Couchbase and Gateway.Core.
/// </summary>
public class {{ entity.name }}Repository : I{{ entity.name }}Repository
{
    private readonly IBucketProvider _bucketProvider;
    private readonly ILogger<{{ entity.name }}Repository> _logger;
    private const string BucketName = "{{ entity.bucket }}";
    private const string ScopeName = "{{ entity.scope }}";
    private const string CollectionName = "{{ entity.collection }}";
{{~ if entity.use_type_discriminator ~}}
    private const string DocumentType = "{{ entity.name_camel_case }}";
{{~ end ~}}

    public {{ entity.name }}Repository(
        IBucketProvider bucketProvider,
        ILogger<{{ entity.name }}Repository> logger)
    {
        _bucketProvider = bucketProvider;
        _logger = logger;
    }

    private async Task<ICouchbaseCollection> GetCollectionAsync()
    {
        var bucket = await _bucketProvider.GetBucketAsync(BucketName);
        var scope = bucket.Scope(ScopeName);
        return scope.Collection(CollectionName);
    }

    public async Task<{{ entity.name }}?> GetByIdAsync(string id, CancellationToken cancellationToken = default)
    {
        var collection = await GetCollectionAsync();

        try
        {
            var result = await collection.GetAsync(id);
            var entity = result.ContentAs<{{ entity.name }}>();
            if (entity != null)
            {
                entity.{{ entity.id_property_name }} = id;
            }
            return entity;
        }
        catch (Couchbase.Core.Exceptions.KeyValue.DocumentNotFoundException)
        {
            return null;
        }
    }

    public async Task<IEnumerable<{{ entity.name }}>> GetAllAsync(CancellationToken cancellationToken = default)
    {
        var bucket = await _bucketProvider.GetBucketAsync(BucketName);
        var scope = bucket.Scope(ScopeName);

        var filter = new FilterBuilder<{{ entity.name }}>();
{{~ if entity.use_type_discriminator ~}}
        filter.Where("type", DocumentType);
{{~ end ~}}
        filter.OrderBy("{{ entity.id_property_name_camel_case }}", descending: false);

        var whereClause = filter.Build();
        var query = $"SELECT META().id AS {{ entity.id_property_name_camel_case }}, e.* FROM `{BucketName}`.`{ScopeName}`.`{CollectionName}` e {whereClause}";

        var queryOptions = new QueryOptions();
        foreach (var param in filter.Parameters)
        {
            queryOptions.Parameter(param.Key, param.Value ?? DBNull.Value);
        }

        return await scope.QueryToListAsync<{{ entity.name }}>(query, queryOptions);
    }

    public async Task<PagedResult<{{ entity.name }}>> GetPageAsync(int pageIndex, int pageSize, CancellationToken cancellationToken = default)
    {
        var bucket = await _bucketProvider.GetBucketAsync(BucketName);
        var scope = bucket.Scope(ScopeName);

        // Build filter with pagination (fetch one extra to detect next page)
        var filter = new FilterBuilder<{{ entity.name }}>();
{{~ if entity.use_type_discriminator ~}}
        filter.Where("type", DocumentType);
{{~ end ~}}
        filter.OrderBy("{{ entity.id_property_name_camel_case }}", descending: false);

        var offset = pageIndex * pageSize;
        filter.Skip(offset).Take(pageSize + 1);

        var whereClause = filter.Build();
        var query = $"SELECT META().id AS {{ entity.id_property_name_camel_case }}, e.* FROM `{BucketName}`.`{ScopeName}`.`{CollectionName}` e {whereClause}";

        var queryOptions = new QueryOptions();
        foreach (var param in filter.Parameters)
        {
            queryOptions.Parameter(param.Key, param.Value ?? DBNull.Value);
        }

        var results = await scope.QueryToListAsync<{{ entity.name }}>(query, queryOptions);

        // Determine if there are more pages
        var hasNextPage = results.Count > pageSize;
        var items = hasNextPage ? results.Take(pageSize).ToList() : results;

        return new PagedResult<{{ entity.name }}>
        {
            Data = items,
            PageIndex = pageIndex,
            PageSize = pageSize,
            TotalCount = hasNextPage ? (pageIndex + 2) * pageSize : (pageIndex * pageSize) + items.Count,
            TotalPages = hasNextPage ? pageIndex + 2 : pageIndex + 1
        };
    }

    public async Task<{{ entity.name }}> CreateAsync({{ entity.name }} entity, CancellationToken cancellationToken = default)
    {
        var collection = await GetCollectionAsync();

        // Generate ID if not provided
        if (string.IsNullOrEmpty(entity.{{ entity.id_property_name }}))
        {
            entity.{{ entity.id_property_name }} = Guid.NewGuid().ToString();
        }

        // Use the ID as the document key (Meta.id())
        var key = entity.{{ entity.id_property_name }};

        // Store document
        var document = new Dictionary<string, object?>
        {
{{~ if entity.use_type_discriminator ~}}
            ["type"] = DocumentType,
{{~ end ~}}
{{~ for property in entity.non_id_properties ~}}
            ["{{ property.name_camel_case }}"] = entity.{{ property.name }},
{{~ end ~}}
        };

        await collection.InsertAsync(key, document);

        _logger.LogInformation("Created {{ entity.name }} with ID: {Id}", entity.{{ entity.id_property_name }});
        return entity;
    }

    public async Task<{{ entity.name }}?> UpdateAsync({{ entity.name }} entity, CancellationToken cancellationToken = default)
    {
        var collection = await GetCollectionAsync();
        var key = entity.{{ entity.id_property_name }};

        try
        {
            var document = new Dictionary<string, object?>
            {
{{~ if entity.use_type_discriminator ~}}
                ["type"] = DocumentType,
{{~ end ~}}
{{~ for property in entity.non_id_properties ~}}
                ["{{ property.name_camel_case }}"] = entity.{{ property.name }},
{{~ end ~}}
            };

            await collection.ReplaceAsync(key, document);
            _logger.LogInformation("Updated {{ entity.name }} with ID: {Id}", entity.{{ entity.id_property_name }});
            return entity;
        }
        catch (Couchbase.Core.Exceptions.KeyValue.DocumentNotFoundException)
        {
            return null;
        }
    }

    public async Task<bool> DeleteAsync(string id, CancellationToken cancellationToken = default)
    {
        var collection = await GetCollectionAsync();

        try
        {
            await collection.RemoveAsync(id);
            _logger.LogInformation("Deleted {{ entity.name }} with ID: {Id}", id);
            return true;
        }
        catch (Couchbase.Core.Exceptions.KeyValue.DocumentNotFoundException)
        {
            return false;
        }
    }
}
